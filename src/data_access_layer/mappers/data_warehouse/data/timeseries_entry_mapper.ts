import Result from '../../../../common_classes/result';
import Mapper from '../../mapper';
import {PoolClient, QueryConfig} from 'pg';
import TimeseriesEntry from '../../../../domain_objects/data_warehouse/data/timeseries';

const format = require('pg-format');

/*
   Timeseries mapper is a unique data mapper capable of storing TimeseriesEntries in the proper Timescaledb hypertables.
   Since those hypertables are autogenerated we have to do a lot of work behind the scenes to make sure we can properly
   insert into every hypertable no matter the structure
*/
export default class TimeseriesEntryMapper extends Mapper {
    private static instance: TimeseriesEntryMapper;

    public static get Instance(): TimeseriesEntryMapper {
        if (!TimeseriesEntryMapper.instance) {
            TimeseriesEntryMapper.instance = new TimeseriesEntryMapper();
        }

        return TimeseriesEntryMapper.instance;
    }

    public async BulkCreate(entries: TimeseriesEntry[], transaction?: PoolClient): Promise<Result<boolean>> {
        return super.runAllStatements(this.createStatement(...entries));
    }

    // Below are a set of query building functions. So far they're very simple
    // and the return value is something that the postgres-node driver can understand
    // My hope is that this method will allow us to be flexible and create more complicated
    // queries more easily.
    private createStatement(...entries: TimeseriesEntry[]): string[] {
        // first we need to get these sorted by transformationID - each different transformation represents a different
        // timescale table structure, we need to handle that. Note that validation should have happened in an earlier step
        // in the repository that matches this mapper
        const toInsert: {[key: string]: TimeseriesEntry[]} = {};

        entries.forEach((entry) => {
            if (toInsert[entry.transformation_id!]) {
                toInsert[entry.transformation_id!].push(entry);
            } else {
                toInsert[entry.transformation_id!] = [entry];
            }
        });

        const insertStatements: string[] = [];

        Object.keys(toInsert).forEach((transformationID) => {
            const text = `INSERT INTO z_${transformationID}(
                                  _nodes,
                                  _metadata,
                                  ${toInsert[transformationID][0].data.map((data) => data.column_name).join(',')}
            ) VALUES %L`;
            const values = [
                toInsert[transformationID].map((entry) => [
                    entry.nodes.length > 0 ? `{${entry.nodes.join(',')}}` : undefined,
                    entry.metadata,
                    ...entry.data.map((data) => data.value),
                ]),
            ];

            insertStatements.push(format(text, values));
        });

        return insertStatements;
    }
}
